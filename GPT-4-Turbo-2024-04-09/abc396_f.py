def read_ints():
    return map(int, input().split())

def count_inversions(arr):
    # Using a Fenwick Tree (Binary Indexed Tree) to count inversions
    class FenwickTree:
        def __init__(self, size):
            self.size = size
            self.tree = [0] * (size + 1)
        
        def add(self, idx, value):
            while idx <= self.size:
                self.tree[idx] += value
                idx += idx & -idx
        
        def sum(self, idx):
            result = 0
            while idx > 0:
                result += self.tree[idx]
                idx -= idx & -idx
            return result
    
    max_val = max(arr)
    ft = FenwickTree(max_val)
    inversions = 0
    for i, num in enumerate(arr):
        inversions += i - ft.sum(num)
        ft.add(num + 1, 1)
    return inversions

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    N = int(data[0])
    M = int(data[1])
    A = list(map(int, data[2:2+N]))
    
    # Calculate the inversion number for each k = 0, 1, ..., M-1
    results = []
    
    # We need to efficiently calculate the inversion number for each B generated by k
    # Direct calculation for each k would be too slow, so we need a more efficient approach.
    
    # We can use a combination of sorting and a Fenwick Tree (or BIT) to calculate inversions efficiently.
    # We will calculate the inversion number for k = 0 directly, then adjust it for each subsequent k.
    
    # Calculate inversion number for k = 0
    B = [(A[i] + 0) % M for i in range(N)]
    inversions = count_inversions(B)
    results.append(inversions)
    
    # We need to adjust the inversion count when k changes
    # When k increases by 1, B[i] = (A[i] + k) % M changes:
    # - If A[i] + k < M, B[i] increases by 1
    # - If A[i] + k >= M, B[i] wraps around (effectively B[i] = (A[i] + k) % M - M)
    
    # We can track how many elements wrap around using a count array
    count_wrap = [0] * M
    for a in A:
        count_wrap[(M - a) % M] += 1
    
    current_wraps = 0
    for k in range(1, M):
        # All elements B[i] where A[i] + k - 1 >= M will wrap around to smaller values
        # This means we need to adjust the inversion count by moving these elements to the front
        # Each wrap reduces the inversion count by (N - current_wraps) - current_wraps
        # because it moves from being larger than (N - current_wraps) elements to being smaller than all
        inversions += (N - 2 * current_wraps)
        results.append(inversions)
        current_wraps += count_wrap[k]
    
    # Print results
    for res in results:
        print(res)

if __name__ == "__main__":
    main()