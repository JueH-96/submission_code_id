import sys
input = sys.stdin.read

MOD = 998244353

def solve():
    data = input().split()
    N = int(data[0])
    M = int(data[1])
    B = list(map(int, data[2:]))
    
    # Count the number of -1s in B
    q = B.count(-1)
    
    # If there are no -1s, we just need to calculate f(B) once
    if q == 0:
        print(f(B, N) % MOD)
        return
    
    # We need to calculate the sum of f(B') over all M^q possible B'
    # where B' is generated by replacing each -1 in B with any number from 1 to M.
    
    # Dynamic programming approach to count connected components for each possible B'
    # dp[i][c] will store the number of ways to form exactly c connected components using the first i elements
    dp = [[0] * (N + 1) for _ in range(N + 1)]
    dp[0][0] = 1  # 0 elements, 0 components is 1 way (empty set)
    
    # Precompute powers of M for each possible count of -1s
    power_M = [1] * (q + 1)
    for i in range(1, q + 1):
        power_M[i] = (power_M[i - 1] * M) % MOD
    
    # Process each element in B
    for i in range(N):
        new_dp = [[0] * (N + 1) for _ in range(N + 1)]
        if B[i] == -1:
            # B[i] can be any value from 1 to M
            # We need to consider adding this new element to any existing component or starting a new component
            for c in range(N):
                if sum(dp[c]) == 0:
                    continue
                # Adding to any existing component
                for j in range(N):
                    if dp[c][j] == 0:
                        continue
                    # This element can join any of the c components
                    new_dp[c][j] = (new_dp[c][j] + dp[c][j] * c) % MOD
                # Starting a new component
                for j in range(N):
                    if dp[c][j] == 0:
                        continue
                    new_dp[c + 1][j + 1] = (new_dp[c + 1][j + 1] + dp[c][j]) % MOD
        else:
            # B[i] is fixed, we can only add it to a component if it matches or start a new component
            for c in range(N):
                if sum(dp[c]) == 0:
                    continue
                # Starting a new component
                for j in range(N):
                    if dp[c][j] == 0:
                        continue
                    new_dp[c + 1][j + 1] = (new_dp[c + 1][j + 1] + dp[c][j]) % MOD
                # Adding to any existing component where the last element is <= B[i]
                for j in range(N):
                    if dp[c][j] == 0 or (j > 0 and B[j - 1] > B[i]):
                        continue
                    new_dp[c][j] = (new_dp[c][j] + dp[c][j]) % MOD
        dp = new_dp
    
    # Sum up the results for all possible numbers of components
    result = 0
    for c in range(1, N + 1):
        result = (result + dp[c][N] * power_M[q]) % MOD
    
    print(result)

def f(B, N):
    # Calculate the number of connected components in the graph defined by B
    parent = list(range(N))
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        rootX = find(x)
        rootY = find(y)
        if rootX != rootY:
            parent[rootY] = rootX
    
    for i in range(N):
        for j in range(i + 1, N):
            if B[i] <= B[j]:
                union(i, j)
    
    # Count unique roots
    unique_roots = len(set(find(i) for i in range(N)))
    return unique_roots