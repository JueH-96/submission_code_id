import collections

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)

        # 1. Build adjacency list for the tree.
        # defaultdict is used for convenience, but a list of lists `[[] for _ in range(n)]`
        # would also work and might be slightly more memory-efficient for fixed N.
        # Children are added in increasing order of their numbers because we iterate
        # `i` from 1 to `n-1`, appending `i` to its parent's list.
        adj = collections.defaultdict(list)
        for i in range(1, n):
            adj[parent[i]].append(i)

        # This array will store the character parity mask for the string generated
        # by dfs(x) for each node x.
        # results_masks[x] represents the XOR sum of character counts for S_x.
        results_masks = [0] * n

        # 2. Define the DFS function to calculate character parity masks.
        # This function computes the mask for the string S_node that would be
        # generated by calling the problem's described dfs(node).
        def dfs_calculate_masks(node):
            # current_node_mask accumulates the XOR sum of masks from children's subtrees
            # and the character s[node] itself.
            current_subtree_mask = 0

            # Iterate over children. adj[node] already has children sorted by number.
            for child in adj[node]:
                # Recursively call DFS for children.
                # The returned child_mask represents the character parities within S_child.
                child_mask = dfs_calculate_masks(child)
                # XORing child masks combines their character parities.
                # If a character appears an odd number of times in two children's strings,
                # it appears an even number of times in their combined string.
                current_subtree_mask ^= child_mask
            
            # After processing all children, account for the character s[node].
            # This is equivalent to appending s[node] to the string dfsStr at the very end
            # for the current node's contribution.
            char_bit = 1 << (ord(s[node]) - ord('a'))
            current_subtree_mask ^= char_bit
            
            # Store the computed mask for the current node.
            results_masks[node] = current_subtree_mask
            
            # Return this mask to the parent node's recursive call, so it can be XORed.
            return current_subtree_mask

        # 3. Start the DFS from the root (node 0).
        # This single DFS pass will correctly populate `results_masks` for all nodes
        # according to the problem's `dfs(x)` string construction logic.
        dfs_calculate_masks(0)

        # 4. Determine if each generated string is a palindrome based on its mask.
        # A string is a palindrome if at most one character has an odd frequency count.
        # In terms of bitmasks:
        # - mask == 0: All character counts are even.
        # - (mask & (mask - 1)) == 0: Exactly one bit is set, meaning exactly one
        #   character has an odd count (e.g., 00100000 & 00011111 = 0).
        answer = [False] * n
        for i in range(n):
            mask = results_masks[i]
            answer[i] = (mask == 0 or (mask & (mask - 1)) == 0)
        
        return answer