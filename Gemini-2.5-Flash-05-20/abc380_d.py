import sys

# Standard input reading
S = sys.stdin.readline().strip()
Q = int(sys.stdin.readline())
Ks = list(map(int, sys.stdin.readline().split()))

initial_len = len(S)

def toggle_case(char):
    """
    Toggles the case of an English letter.
    'a' -> 'A', 'B' -> 'b', etc.
    Constraints ensure S consists only of English letters.
    """
    if 'a' <= char <= 'z':
        # Convert lowercase to uppercase by subtracting 32 from ASCII value
        return chr(ord(char) - 32)
    elif 'A' <= char <= 'Z':
        # Convert uppercase to lowercase by adding 32 to ASCII value
        return chr(ord(char) + 32)
    return char # Should not be reached given constraints

def find_char_recursive(k_val, current_segment_len, toggle_count):
    """
    Recursively finds the k_val-th character within a conceptual string segment.

    Args:
        k_val (int): The 1-indexed position of the character we are looking for
                     relative to the current_segment_len.
        current_segment_len (int): The length of the conceptual string segment
                                   we are currently examining (e.g., L_m, L_{m-1}, etc.).
        toggle_count (int): The cumulative number of times the character's case
                            has been toggled since its origin in the initial string S.

    Returns:
        str: The character at the specified k_val position after all operations.
    """
    
    # Base case: When current_segment_len equals initial_len, we have narrowed down
    # the search to a character within the original string S.
    if current_segment_len == initial_len:
        # k_val is 1-indexed, so S[k_val - 1] gets the 0-indexed character.
        char_from_S = S[k_val - 1]
        
        # If toggle_count is odd, the character's case needs to be toggled once.
        # If even, it returns to its original case.
        if toggle_count % 2 == 1:
            return toggle_case(char_from_S)
        else:
            return char_from_S
    
    # Recursive step: Determine which half of the current segment the character resides in.
    # The current segment (e.g., S_x) is conceptually formed by S_{x-1} + T_{x-1}.
    half_segment_len = current_segment_len // 2
    
    if k_val <= half_segment_len:
        # The character is in the first half (the S_{x-1} part).
        # Its relative position k_val and toggle_count remain unchanged.
        return find_char_recursive(k_val, half_segment_len, toggle_count)
    else:
        # The character is in the second half (the T_{x-1} part).
        # This part was generated by case-toggling S_{x-1}.
        # Its new relative position within T_{x-1} is k_val - half_segment_len.
        # The toggle_count must be incremented because it originated from a toggled segment.
        return find_char_recursive(k_val - half_segment_len, half_segment_len, toggle_count + 1)

# Process each query K_i
results = []
for k_query in Ks:
    # For each K_i, we first find the smallest string length (S_m) that encompasses K_i.
    # This loop determines the `current_segment_len` for the initial call to find_char_recursive.
    current_effective_len = initial_len
    
    while current_effective_len < k_query:
        # Double the current_effective_len until it's large enough to contain k_query.
        # This represents moving from S_0 to S_1, S_1 to S_2, and so on, until S_m.
        current_effective_len *= 2
    
    # Now, current_effective_len holds the length of the string S_m that contains K_i.
    # Call the recursive function. The initial toggle_count is 0 as we start from S_m.
    results.append(find_char_recursive(k_query, current_effective_len, 0))

# Print all results, separated by spaces, followed by a newline.
sys.stdout.write(' '.join(results) + '
')