import math
from typing import List

class Solution:
    """
    Finds the length of the shortest subarray of an infinitely repeating array `nums`
    that sums to `target`. The infinite array `infinite_nums` is generated by appending `nums` to itself infinitely.
    """
    def minSizeSubarray(self, nums: List[int], target: int) -> int:
        
        n = len(nums)
        total_S = sum(nums)
        
        # Since all nums[i] >= 1, the total sum total_S must be >= 1 (unless n=0, but constraints say 1 <= n).
        
        # Calculate how many full repetitions of `nums` are definitely part of a potential solution.
        # This is given by `k = target // total_S`.
        k = target // total_S
        
        # Calculate the remaining sum needed after accounting for `k` full repetitions.
        # `rem = target % total_S`.
        rem = target % total_S
        
        # The shortest subarray summing to `target` can arise in two main ways:
        # 1. It's fully contained within a segment of `infinite_nums` of length 2*n.
        #    This covers subarrays within a single `nums` copy and those wrapping around once.
        #    We can find this by searching in `nums + nums`.
        # 2. It spans multiple full copies of `nums`. This structure typically looks like
        #    `k` full copies plus a subarray summing to `rem`.
        #    If `rem` is 0, it means `target` is a multiple of `total_S`. The structure would
        #    involve `k-1` full copies plus a shortest subarray summing to `total_S`.

        # To handle both cases uniformly, define an `effective_rem_target` and `effective_k`.
        effective_rem_target = rem
        effective_k = k
        
        if rem == 0:
            # If target is a multiple of total_S. Since target >= 1, it implies k >= 1.
            # The problem effectively becomes finding the shortest subarray summing to total_S,
            # potentially preceded by k-1 full cycles.
            effective_rem_target = total_S 
            effective_k = k - 1  # Use k-1 full cycles
            # Note: If target=S, k=1, rem=0. Then effective_k=0, effective_rem_target=S.
            # The candidate length formula becomes 0*n + min_len(S), which is correct.
            # If target > S and is multiple of S, k > 1, effective_k >= 1.

        # Create the doubled array to search for subarrays within a 2N window.
        double_nums = nums + nums
        
        # Initialize minimum lengths found within the 2N window to infinity.
        min_len_target = float('inf')  # Shortest length for the exact `target` sum
        min_len_effective_rem = float('inf') # Shortest length for `effective_rem_target` sum
        
        # Use a hash map to store prefix sums and the first index where they occur.
        # Map structure: {prefix_sum_value: earliest_end_index_j}
        # Prefix sum P[j+1] = sum(double_nums[0..j]). Map stores { P[j+1]: j }
        # Initialize with prefix sum 0 occurring at index -1 (conceptually before the array starts).
        prefix_sums = {0: -1} 
        current_sum = 0
        
        # Iterate through the doubled array. `j` represents the ending index (inclusive) of potential subarrays.
        for j in range(2 * n):
            current_sum += double_nums[j]
            
            # Check if `current_sum - target` exists as a previous prefix sum.
            # If `P[j+1] - P[i+1] = target`, then `P[i+1] = P[j+1] - target`.
            req_target_prefix_sum = current_sum - target
            if req_target_prefix_sum in prefix_sums:
                # Found a subarray ending at `j` with sum `target`.
                # The start index is `prefix_sums[req_target_prefix_sum] + 1`.
                # The length is `j - prefix_sums[req_target_prefix_sum]`.
                length = j - prefix_sums[req_target_prefix_sum]
                min_len_target = min(min_len_target, length)
            
            # Check if `current_sum - effective_rem_target` exists as a previous prefix sum.
            req_effective_rem_prefix_sum = current_sum - effective_rem_target
            if req_effective_rem_prefix_sum in prefix_sums:
                 # Found a subarray ending at `j` with sum `effective_rem_target`.
                 length = j - prefix_sums[req_effective_rem_prefix_sum]
                 min_len_effective_rem = min(min_len_effective_rem, length)

            # Store the current prefix sum `current_sum` (which is P[j+1]) and its index `j`.
            # Only store if it's the first time encountering this prefix sum value to ensure
            # we track the earliest occurrence for shortest length calculation.
            if current_sum not in prefix_sums:
                prefix_sums[current_sum] = j

        # Initialize the overall minimum possible length.
        ans = float('inf')

        # Consider Candidate 1: The shortest length found directly for `target` within the 2N window.
        if min_len_target != float('inf'):
             ans = min_len_target
        
        # Consider Candidate 2: Based on using `effective_k` full cycles plus the shortest subarray 
        # found for `effective_rem_target`. This covers cases where the optimal solution spans many cycles.
        if min_len_effective_rem != float('inf'):
             # Calculate the total length for this candidate.
             # `effective_k` is guaranteed to be >= 0 because if k=0, rem must be > 0 (target < S),
             # or if k=0 and rem=0, then target=0, which contradicts target >= 1.
             candidate_len = effective_k * n + min_len_effective_rem
             # Update the overall minimum length if this candidate is shorter.
             ans = min(ans, candidate_len)

        # If `ans` remains infinity, it means no subarray summing to `target` was found.
        if ans == float('inf'):
            return -1
        else:
            # Otherwise, return the minimum length found.
            return ans