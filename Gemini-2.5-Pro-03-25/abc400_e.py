# YOUR CODE HERE
import sys
import math
import bisect

def solve():
    """
    Solves the problem by precomputing numbers M <= 10^6 with exactly 2 distinct prime factors,
    then for each query A, finding the largest such M <= sqrt(A) using binary search,
    and outputting M^2.

    A positive integer N is a 400 number if:
    1. N has exactly 2 distinct prime factors.
    2. For each prime factor p of N, the exponent k in N's prime factorization (p^k divides N) is even.
    This implies N must be a perfect square, N = M^2. The condition simplifies to M having exactly 2 distinct prime factors.
    
    Given query A, we need to find the largest 400 number N <= A.
    This is equivalent to finding the largest M such that M has exactly 2 distinct prime factors and M^2 <= A.
    This further simplifies to finding the largest M <= floor(sqrt(A)) such that M has exactly 2 distinct prime factors.

    The maximum value A can take is 10^12, so the maximum value M can take is floor(sqrt(10^12)) = 10^6.
    We precompute all M <= 10^6 that satisfy the condition.
    """
    
    # Precomputation phase
    # Maximum possible value for M is 10^6.
    MAX_M = 10**6 
    
    # Use a sieve to count the number of distinct prime factors for each number up to MAX_M.
    # dpf[k] will store the number of distinct prime factors of k.
    dpf = [0] * (MAX_M + 1)

    # Sieve implementation: Time complexity O(N log log N) where N = MAX_M.
    # This sieve iterates through potential primes i. If i is found to be prime (dpf[i] == 0),
    # it then iterates through all multiples j of i up to MAX_M and increments dpf[j].
    # This ensures dpf[j] correctly counts the number of distinct prime factors of j.
    for i in range(2, MAX_M + 1):
        # If dpf[i] is 0, it means i is prime, as it hasn't been marked by any smaller prime factors' loops.
        if dpf[i] == 0: 
            # Iterate through multiples of the prime i, starting from i itself.
            for j in range(i, MAX_M + 1, i):
                # Increment the count of distinct prime factors for j.
                dpf[j] += 1

    # Build the list S containing integers m <= MAX_M that have exactly 2 distinct prime factors.
    S = []
    # Iterate through numbers m from 1 to MAX_M.
    # Smallest number with 2 distinct prime factors is 2*3 = 6.
    for m in range(1, MAX_M + 1):
        # Check if m has exactly 2 distinct prime factors based on the sieve result.
        if dpf[m] == 2:
            S.append(m)
    
    # The list S is generated by iterating m in increasing order, so it is already sorted.

    # Precompute the squares of the elements in S. These squares are the actual 400 numbers.
    # N = M^2 is a 400 number if and only if M has exactly 2 distinct prime factors.
    S_squared = [m*m for m in S]
    
    # Read the number of queries Q from standard input.
    Q = int(sys.stdin.readline())

    # Process each query.
    # Store results to print them all at once at the end, potentially faster I/O.
    results = []
    for _ in range(Q):
        # Read the query value A from standard input.
        A = int(sys.stdin.readline())
        
        # Compute the integer square root of A. We are looking for the largest M such that M^2 <= A,
        # which is equivalent to M <= sqrt(A). Let K be floor(sqrt(A)).
        # math.isqrt is used for accurate integer square roots, especially for large numbers. Available in Python 3.8+.
        K = math.isqrt(A) 
        
        # Use binary search on the sorted list S to find the largest M <= K.
        # `bisect.bisect_right(S, K)` returns an insertion index `idx` such that:
        # - All elements S[i] for i < idx satisfy S[i] <= K.
        # - All elements S[j] for j >= idx satisfy S[j] > K.
        idx = bisect.bisect_right(S, K)
        
        # The largest element M in S satisfying M <= K is located at index `idx - 1`.
        # The problem guarantees A >= 36, which means K = isqrt(A) >= isqrt(36) = 6.
        # The smallest element in S is 6 (2*3), so S[0] = 6.
        # Since K >= 6, the binary search will always find at least S[0]=6 if K=6, or larger elements if K>6.
        # Thus, `idx` returned by `bisect_right` will be at least 1.
        # Therefore, `idx - 1` is always a valid non-negative index into S and S_squared.
        
        # The answer to the query A is the square of this largest M. We retrieve it from the precomputed S_squared list.
        results.append(S_squared[idx - 1])

    # Print all the computed results for the queries, each on a new line.
    # Use '
'.join(map(str, results)) + '
' and sys.stdout.write could be slightly faster for huge output,
    # but standard print is generally sufficient and more readable.
    for res in results:
        print(res)

# Execute the main solve function when the script is run.
# This check prevents the code from running when imported as a module.
if __name__ == '__main__':
    solve()