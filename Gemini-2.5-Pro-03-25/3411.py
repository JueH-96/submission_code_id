import sys
# Setting recursion depth is generally not needed for iterative solutions,
# but potentially useful if any helper function was recursive.
# sys.setrecursionlimit(2000) 

from typing import List
from functools import lru_cache

class Solution:
    
    def __init__(self):
       # Using @lru_cache decorator handles caching automatically.
       # Caches are associated with the instance methods.
       # In typical competitive programming setups (like LeetCode),
       # a new Solution instance is created for each test case, effectively clearing caches.
       # If the same instance were reused, caches would persist. We can explicitly clear them if needed.
       pass

    # Calculates the total number of set bits in integers from 1 to N.
    # This corresponds to the total length of big_nums generated by integers 1 through N.
    # S(N) = Sum_{i=1..N} popcount(i)
    @lru_cache(maxsize=None)
    def countSetBits(self, N):
        # Base case: N=0 or negative, sum is 0.
        if N <= 0: return 0
        
        res = 0
        k = 0 # bit position (0-indexed)
        pow2_k = 1 # 2^k
        pow2_k1 = 2 # 2^(k+1)
        
        # Iterate through bit positions k. Max relevant k is related to N.bit_length().
        # Using pow2_k <= N ensures we only consider bits potentially present in numbers up to N.
        while pow2_k <= N:
            # Calculate number of full blocks of size 2^(k+1) in range [0, N]
            q = (N + 1) // pow2_k1
            # Calculate remainder length
            r = (N + 1) % pow2_k1
            # Count how many numbers in [1, N] have the k-th bit set.
            # Each full block contributes 2^k set bits at position k.
            # The remaining part contributes max(0, r - 2^k) set bits.
            count_k = q * pow2_k + max(0, r - pow2_k)
            res += count_k # Add to total count of set bits
            
            # Move to the next bit position
            k += 1
            pow2_k *= 2
            pow2_k1 *= 2
            
        return res

    # Calculates the sum of exponents of powers of 2 in the powerful arrays for integers 1 to N.
    # Sum_{i=1..N} T(i), where T(i) = Sum_{k where i has k-th bit set} k
    @lru_cache(maxsize=None)
    def totalExponentSum(self, N):
        if N <= 0: return 0

        res = 0
        k = 0 # bit position (exponent)
        pow2_k = 1 # 2^k
        pow2_k1 = 2 # 2^(k+1)

        while pow2_k <= N:
            # Same logic as countSetBits to find count_k: numbers in [1, N] with k-th bit set.
            q = (N + 1) // pow2_k1
            r = (N + 1) % pow2_k1
            count_k = q * pow2_k + max(0, r - pow2_k)
            # Each number with k-th bit set contributes k to the total exponent sum.
            res += k * count_k 
            
            # Move to the next bit position
            k += 1
            pow2_k *= 2
            pow2_k1 *= 2
            
        return res

    # Binary search to find the smallest integer N such that the total length S(N) >= idx + 1.
    # This N is the integer whose powerful array contains the element at big_nums[idx].
    def findN(self, idx):
        low = 0
        # Upper bound for N. If idx ~ 10^15, N ~ 10^15 / log(10^15) ~ 2*10^13.
        # 2^45 is approx 3.5*10^13. Use 2^60 as a safe upper bound.
        high = 1 << 60 
        ansN = 0
        
        while low <= high:
            # Use midpoint calculation that avoids overflow in languages with fixed-size integers
            mid = low + (high - low) // 2 
            
            # Get S(mid) = total length up to integer mid. Handles mid=0 correctly.
            S_mid = self.countSetBits(mid)

            # We are looking for the smallest N such that S(N) > idx.
            # This implies N's powerful array starts at index S(N-1) and ends at S(N)-1.
            # The element at index idx belongs to N if S(N-1) <= idx < S(N).
            if S_mid > idx:
                 ansN = mid # This mid might be the N we are looking for
                 high = mid - 1 # Try searching in the lower half for a potentially smaller N
            else: # S_mid <= idx
                 # The element at idx must come from an integer >= mid+1.
                 low = mid + 1 # Search in the upper half
                 
        return ansN

    # Calculates the sum of exponents for the first 'count' elements of N's powerful array.
    # The powerful array elements correspond to set bits in N, sorted by exponent value.
    def getPartialExponentSum(self, N, count):
        if count <= 0: return 0
        exp_sum = 0
        bits_found = 0
        k = 0 # exponent (bit position)
        temp_N = N # Use a temporary variable to iterate through bits
        
        # Iterate through bits of N from LSB to MSB
        while temp_N > 0 and bits_found < count:
            if temp_N & 1: # Check if the current k-th bit (LSB of temp_N) is set
                bits_found += 1
                exp_sum += k # Add the exponent k to the sum
            
            # Move to the next bit by right shifting N
            temp_N >>= 1
            k += 1 # Increment exponent/bit position
        return exp_sum

    # Calculate total exponent sum E(idx) = Sum_{j=0..idx} K(j) where big_nums[j] = 2^K(j).
    @lru_cache(maxsize=8192) # Limited cache size due to potentially large and non-repeating idx values.
    def GetExponentSum(self, idx):
        # Base case for index -1 (needed for range start calculation)
        if idx < 0: return 0

        # Find the integer N whose powerful array contains big_nums[idx]
        N = self.findN(idx)
        # If N=0, it implies idx is invalid or < 0 (handled), or error. Correct logic shouldn't yield N=0 for idx >= 0.
        if N == 0: return 0 
        
        # Get total length S(N-1) and total exponent sum up to N-1
        S_N_minus_1 = self.countSetBits(N - 1)
        Sum_N_minus_1 = self.totalExponentSum(N - 1)
        
        # Calculate how many elements from N's powerful array are included up to index idx.
        # The first element from N is at index S(N-1).
        # The element at index idx is the (idx - S(N-1))-th element from N (0-indexed).
        # So we need the sum of exponents for the first (idx - S(N-1) + 1) elements.
        rem_count = idx - S_N_minus_1 + 1
        # Should not be negative if findN logic is correct. Add safeguard.
        if rem_count < 0: rem_count = 0 

        # Calculate the sum of exponents for these initial elements from N's powerful array.
        Sum_rem = self.getPartialExponentSum(N, rem_count)
        
        # The total exponent sum up to idx is the sum up to N-1 plus the partial sum from N.
        total_sum = Sum_N_minus_1 + Sum_rem
        return total_sum
    
    # Calculate Euler's totient function phi(n). Required for modular exponentiation reduction.
    @lru_cache(maxsize=None) # Cache phi results. Max distinct mod_i is 10^5.
    def phi(self, n):
        if n == 1: return 1 # phi(1) = 1
        result = n
        p = 2
        # Handle factor 2 separately for optimization
        if n % 2 == 0:
             result -= result // 2 # equivalent to result = result * (1 - 1/2)
             while n % 2 == 0:
                 n //= 2 # Remove all factors of 2
        # Check odd factors starting from 3
        p = 3
        while p * p <= n:
            if n % p == 0:
                result -= result // p # result = result * (1 - 1/p)
                while n % p == 0: # Remove all factors of p
                    n //= p
            p += 2 # Check next odd number
        # If n > 1 after the loop, it means n has a prime factor > sqrt(original n)
        if n > 1:
            result -= result // n # result = result * (1 - 1/n)
        return result

    # Calculate (base^exp) % mod using binary exponentiation (exponentiation by squaring).
    def power(self, base, exp, mod):
        res = 1
        base %= mod # Reduce base modulo mod first
        while exp > 0:
            if exp % 2 == 1: # If exponent is odd
                res = (res * base) % mod
            # Square the base and take modulo
            base = (base * base) % mod
            # Halve the exponent
            exp //= 2
        return res

    # Find the largest integer p such that 2^p divides mod.
    @lru_cache(maxsize=None) # Cache results. Max distinct mod_i is 10^5.
    def get_p(self, mod):
       # Handle invalid mod input. Constraints state mod >= 1.
       if mod <= 0: return 64 # Return a large safe value
       # If mod is odd, p=0.
       if mod % 2 != 0: return 0
       
       # Efficient bit manipulation: find the exponent of the lowest set bit.
       # (mod & -mod) isolates the lowest power of 2 that divides mod.
       # Example: mod=12 (1100), -mod = (...0100). mod & -mod = 0100 = 4 = 2^2. p=2.
       # .bit_length() returns position+1. So subtract 1 to get exponent p.
       lowest_set_bit = mod & -mod
       p = lowest_set_bit.bit_length() - 1
       return p

    # Main method to process all queries.
    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:
        ans = [] # Stores results for each query
        for q in queries:
            from_i, to_i, mod_i = q[0], q[1], q[2]
            
            # Edge case: If mod is 1, the result is always 0.
            if mod_i == 1:
                ans.append(0)
                continue

            # Calculate the total exponent E_total for the product range [from_i, to_i].
            # E_total = Sum_{j=from_i..to_i} K(j) = E(to_i) - E(from_i - 1).
            E_to = self.GetExponentSum(to_i)
            E_from_minus_1 = self.GetExponentSum(from_i - 1)
            E_total = E_to - E_from_minus_1
            
            # Find p = largest exponent such that 2^p divides mod_i.
            p = self.get_p(mod_i)
            
            # Compute (2 ^ E_total) % mod_i using properties of modular exponentiation.
            # Uses Euler's totient theorem extension:
            # a^k === a^(k mod phi(m) + phi(m)) (mod m) for k >= max_exponent_of_prime_factors_of_m_dividing_a.
            # Here a=2, m=mod_i. The condition is k >= p.
            
            if E_total < p:
                 # If exponent E_total < p, 2^E_total might not be 0 mod 2^p.
                 # Direct modular exponentiation is sufficient and correct.
                 result = self.power(2, E_total, mod_i)
            else: 
                 # If exponent E_total >= p, we can safely apply the theorem.
                 phi_m = self.phi(mod_i)
                 # Euler totient phi(m) is always positive for m >= 1.
                 
                 # Calculate the reduced exponent E' = (E_total mod phi(m)) + phi(m)
                 exp_reduced = E_total % phi_m
                 final_exp = exp_reduced + phi_m
                 # Compute 2^E' % mod_i
                 result = self.power(2, final_exp, mod_i)

            ans.append(result) # Add result for the current query
            
        return ans # Return list of results for all queries