import sys
# Optional: Increase recursion depth if needed, though this solution is iterative.
# sys.setrecursionlimit(2000) 
from typing import List

class Solution:
    """
    Solves the problem of finding the sequence of strings generated
    on a special keyboard to type a target string with minimum key presses.
    The keyboard has two keys:
    1. Key 1: Append 'a'.
    2. Key 2: Change the last character to the next one alphabetically (z wraps around to a).
    
    The goal is to return the list of all strings that appear on the screen
    in the order they are generated while typing the `target` string using
    the minimum number of key presses.
    """
    def stringSequence(self, target: str) -> List[str]:
        """
        Generates the sequence of strings appearing on the screen when typing
        the target string using the minimum number of key presses.

        The strategy is to build the target string prefix by prefix. To get from
        prefix `target[:i]` to `target[:i+1]`, we must first press Key 1 to append 'a',
        resulting in `target[:i] + 'a'`. Then, we press Key 2 repeatedly to change
        the last character 'a' to `target[i]`. This sequence of operations is
        provably optimal (minimum key presses) because Key 1 is the only way to
        increase string length, and Key 2 is the only way to modify the last character.

        Args:
            target: The target string consisting of lowercase English letters. 
                    Constraints guarantee 1 <= target.length <= 400.

        Returns:
            A list of all strings that appear on the screen in the order they
            are generated.
        """
        # Stores the sequence of strings generated during the process
        result = []
        # Represents the current string on the screen as a list of characters.
        # Using a list is efficient for modifying the last character.
        current_chars = []

        # Constraints state target.length >= 1, so the loop will run at least once.
        
        # Iterate through each character of the target string to build it prefix by prefix.
        # In each iteration `i`, we aim to transform the current string (which matches `target[:i]`)
        # into the string matching `target[:i+1]`.
        for i in range(len(target)):
            # The target character for the current position (index i)
            target_char = target[i]

            # --- Operation 1: Press Key 1 (Append 'a') ---
            # To increase the length of the string and match the next prefix of the target,
            # we must first press Key 1 to append 'a'. This is the only operation
            # that increases the string length.
            # This action corresponds to one key press.
            current_chars.append('a')
            # Record the string state ("...a") after this key press.
            # "".join(current_chars) efficiently creates the string from the list of characters.
            result.append("".join(current_chars))

            # --- Operation 2: Press Key 2 repeatedly ---
            # The last character of the current string is now 'a'. We need to transform it
            # into the desired `target_char` by repeatedly pressing Key 2.
            # Each press advances the character alphabetically, with 'z' wrapping around to 'a'.
            # We continue pressing Key 2 until the last character matches `target_char`.
            while current_chars[-1] != target_char:
                # Each iteration of this loop corresponds to one press of Key 2.

                # Get the ASCII ordinal value of the current last character.
                last_char_ord = ord(current_chars[-1])

                # Calculate the ASCII ordinal value of the next character in the alphabetical sequence.
                # The modulo arithmetic ensures correct wrapping from 'z' to 'a'.
                # Calculation Breakdown:
                # 1. (last_char_ord - ord('a')): Converts the character ('a'...'z') to a 0-based index (0...25).
                # 2. + 1: Increments the index to get the index of the next character alphabetically.
                # 3. % 26: Takes the remainder when divided by 26. This handles the wrap-around:
                #    index 25 ('z') + 1 becomes 26, and 26 % 26 = 0, which is the index for 'a'.
                # 4. + ord('a'): Converts the resulting 0-based index back to its ASCII character value.
                next_char_ord = (last_char_ord - ord('a') + 1) % 26 + ord('a')

                # Update the last character in our list representation of the string.
                current_chars[-1] = chr(next_char_ord)

                # Record the string state after this press of Key 2. Each intermediate string
                # generated by Key 2 presses must be included in the result list.
                result.append("".join(current_chars))

        # After the loop finishes, `current_chars` represents the final `target` string,
        # and `result` contains the complete sequence of all strings generated in order
        # to reach the target using the minimum number of key presses.
        return result