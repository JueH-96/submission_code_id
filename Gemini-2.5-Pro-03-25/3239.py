import collections

class Solution:
    """
    Finds the minimum number of operations to make x equal to y using BFS.
    Allowed operations on x: 
    1. Divide by 11 if x is a multiple of 11.
    2. Divide by 5 if x is a multiple of 5.
    3. Decrement x by 1.
    4. Increment x by 1.
    Constraints: 1 <= x, y <= 10^4.
    """
    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:
        """
        Performs a Breadth-First Search (BFS) from x to find the minimum
        number of operations to reach y.
        
        Args:
            x: The starting positive integer.
            y: The target positive integer.
            
        Returns:
            The minimum number of operations required to transform x into y.
        """
        # Trivial case: x is already equal to y. No operations needed.
        if x == y:
            return 0

        # Initialize the BFS queue with the starting state.
        # Each element in the queue is a tuple: (current_value, number_of_operations)
        queue = collections.deque([(x, 0)]) 
        
        # Keep track of visited states (values of x) to prevent cycles and 
        # redundant computations. Using a set for efficient lookups.
        # BFS guarantees that the first time we visit a state, it's via 
        # the shortest path in terms of number of operations.
        visited = {x} 

        # Start the BFS process.
        while queue:
            # Dequeue the state with the fewest operations processed so far.
            current_x, current_ops = queue.popleft()

            # --- Explore potential next states generated by the allowed operations ---

            # Create a list of potential next values to explore from current_x
            potential_next_vals = []
            
            # Operation: Increment by 1
            potential_next_vals.append(current_x + 1)
            # Operation: Decrement by 1
            potential_next_vals.append(current_x - 1)
            # Operation: Divide by 5 (if possible)
            if current_x % 5 == 0:
                potential_next_vals.append(current_x // 5)
            # Operation: Divide by 11 (if possible)
            if current_x % 11 == 0:
                potential_next_vals.append(current_x // 11)

            # Process each potential next state
            for next_x in potential_next_vals:
                # --- Check validity and process the next state ---

                # 1. Check if the target is reached
                if next_x == y:
                    # Found the target, return the total operations.
                    return current_ops + 1

                # 2. Check basic validity: must be a positive integer.
                if next_x < 1:
                    continue
                
                # 3. Apply a heuristic upper bound to prune the search space.
                # Based on analysis of constraints (1 <= x, y <= 10000) and operations,
                # states significantly larger than max(x, y) + 11 are unlikely 
                # to be on the optimal path. A fixed bound slightly above the
                # maximum constraint value seems safe and sufficient.
                # Using 11001 allows reaching multiples like 11 * 1000 = 11000 and 
                # handles cases like x=10000 needing to reach 10010 for division by 11.
                if next_x > 11001: # Heuristic bound based on constraints
                    continue
                    
                # 4. Check if this state has already been visited.
                # If visited, we've already found the shortest path to it, so skip.
                if next_x not in visited:
                    # Mark the new state as visited.
                    visited.add(next_x)
                    # Enqueue the new state with incremented operation count.
                    queue.append((next_x, current_ops + 1))

        # This part should theoretically not be reached if y is always reachable from x
        # under the given operations and constraints. It's included as a safeguard.
        return -1