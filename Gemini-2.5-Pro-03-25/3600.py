import math

class Solution:
    def kthCharacter(self, k: int) -> str:
        """
        Calculates the k-th character (1-based index) in the infinite string 
        generated by the described process.

        The string generation process is as follows:
        Start with word = "a".
        Repeatedly perform the operation: 
          Generate a new string by changing each character in the current `word` 
          to its next character in the English alphabet ('z' becomes 'a').
          Append this new string to the original `word`.

        Example trace:
        Initial: W_0 = "a" (length 1)
        Op 1: next("a")="b", word becomes W_1 = "ab" (length 2)
        Op 2: next("ab")="bc", word becomes W_2 = "abbc" (length 4)
        Op 3: next("abbc")="bccd", word becomes W_3 = "abbcbccd" (length 8)
        In general, W_n = W_{n-1} + next(W_{n-1}), and length(W_n) = 2^n.

        Let f(k) be the k-th character in the final infinite string.
        We can observe a recursive pattern:
        - f(1) = 'a'.
        - For k > 1, find the largest power of 2, let's call it `m`, such that `m < k`. 
          This `m` corresponds to the length of the block W_p where 2^p = m.
          The k-th character lies in the second half of the block W_{p+1} (which has length 2m).
          The second half is `next(W_p)`.
          The position of the k-th character within this second half is `k - m`.
          Therefore, the k-th character `f(k)` is the 'next' version of the character 
          at position `k - m` in the previous block `W_p`.
          This gives the recursive relation: `f(k) = next(f(k - m))`.

        This means that the character `f(k)` is obtained by starting with 'a' (which is f(1)) 
        and applying the `next` character operation a certain number of times. Let N(k) 
        be the number of times the `next` operation is applied.
        The recurrence for N(k) is:
        - N(1) = 0
        - N(k) = 1 + N(k - m) for k > 1.

        It can be shown (by induction or by observing the structure related to binary representations) 
        that N(k) is equal to the number of set bits (1s) in the binary representation of `k - 1`. 
        This is often called the population count or Hamming weight, denoted as `popcount(k - 1)`.

        The `next` character operation ('a' -> 'b', ..., 'z' -> 'a') corresponds to adding 1 
        modulo 26 to the character's 0-based index ('a'=0, 'b'=1, ..., 'z'=25).

        Starting from 'a' (index 0), after applying the `next` operation `popcount(k - 1)` times,
        the final character's 0-based index will be `(0 + popcount(k - 1)) % 26`.

        The algorithm is therefore:
        1. Calculate `num_ops = popcount(k - 1)`.
        2. Calculate the final character index `final_idx = num_ops % 26`.
        3. Convert this index back to a character: `chr(ord('a') + final_idx)`.
        
        Constraints: 1 <= k <= 500. This range is small, so the `popcount` calculation is very fast.
        """

        # Calculate popcount(k - 1).
        # bin(k - 1) returns the binary representation as a string, e.g., "0b101".
        # The .count('1') method counts the occurrences of '1' in this string.
        # This handles the edge case k=1 correctly: k-1=0, bin(0)="0b0", count('1')=0.
        num_next_operations = bin(k - 1).count('1')
        
        # Calculate the final character's 0-based index relative to 'a'.
        # The result is taken modulo 26 because the alphabet wraps around ('z' goes to 'a').
        final_char_index = num_next_operations % 26
        
        # Convert the 0-based index back to the corresponding lowercase English character.
        # ord('a') gives the ASCII value of 'a'. Adding the calculated index gives the 
        # ASCII value of the target character. chr() converts this ASCII value back to a character.
        result_character = chr(ord('a') + final_char_index)
        
        return result_character