# YOUR CODE HERE
import sys

# It's generally good practice to increase recursion depth for competitive programming,
# Although the provided iterative 'find' function avoids deep recursion issues.
# sys.setrecursionlimit(400005) # N + M approx max size could be up to 400000

def solve():
    # Read number of vertices N and number of operations M
    N, M = map(int, sys.stdin.readline().split())

    # Store operations. Each operation is a dictionary with 'cost' and 'vertices' list.
    operations = []
    for _ in range(M):
        # Read K_i (number of vertices in set S_i) and C_i (cost for this operation)
        line1 = sys.stdin.readline().split()
        # K = int(line1[0]) # K_i is implicitly len(A), so not strictly needed after reading A
        C = int(line1[1]) 
        # Read the list of vertices A_{i,1}, ..., A_{i, K_i}
        A = list(map(int, sys.stdin.readline().split())) 
        operations.append({'cost': C, 'vertices': A})

    # Sort the operations based on their cost C in non-decreasing order.
    # This is crucial for the Kruskal's algorithm based approach, ensuring we consider
    # cheaper potential edges first.
    operations.sort(key=lambda x: x['cost'])

    # Initialize Union-Find data structure components.
    # We use 1-based indexing for vertices, so arrays are size N+1.
    # `parent[i]` stores the parent of vertex i in the UF tree. Initially, each vertex is its own parent.
    parent = list(range(N + 1)) 
    # `size[i]` stores the size of the component (tree) rooted at i.
    # Used for the union-by-size heuristic to keep the trees relatively balanced.
    size = [1] * (N + 1)

    # Iterative find function with path compression.
    # Finds the representative (root) of the set containing element i.
    # Path compression optimizes future finds by making nodes point directly to the root.
    def find(i):
        root = i
        # Traverse up the tree to find the root
        while parent[root] != root:
            root = parent[root]
        
        # Path compression: traverse the path from i to root again,
        # making each node point directly to the root.
        curr = i
        while parent[curr] != root:
            next_node = parent[curr] # Store next node before changing parent pointer
            parent[curr] = root
            curr = next_node
        return root

    # Union function with union-by-size heuristic.
    # Merges the sets containing elements i and j if they are in different sets.
    # Returns True if a merge occurred (i.e., they were in different sets), False otherwise.
    def union(i, j):
        # Find the roots of the sets containing i and j
        root_i = find(i)
        root_j = find(j)
        
        # If i and j are already in the same set, do nothing and return False
        if root_i != root_j:
            # Union by size: Attach the smaller tree to the root of the larger tree.
            # This heuristic helps maintain shallow tree structures, improving efficiency.
            if size[root_i] < size[root_j]:
                # Make root_j the parent of root_i
                parent[root_i] = root_j
                # Update the size of the merged tree rooted at root_j
                size[root_j] += size[root_i]
            else: # size[root_i] >= size[root_j]
                # Make root_i the parent of root_j
                parent[root_j] = root_i
                # Update the size of the merged tree rooted at root_i
                size[root_i] += size[root_j]
            return True # Return True indicating that a union operation occurred
        return False # Return False if i and j were already in the same set

    total_weight = 0 # Accumulator for the total weight of the Minimum Spanning Tree (MST)
    edges_count = 0 # Counter for the number of edges added to the MST
    
    # Process the operations in the order of increasing cost (similar to Kruskal's algorithm)
    for op in operations:
        C = op['cost'] # The cost associated with edges generated by this operation
        S = op['vertices'] # The set of vertices involved in this operation
        
        # The problem constraints state K_i >= 2, which means len(S) >= 2.
        # We don't need an explicit check for len(S) < 2.
        
        # Pick the first vertex in the set S as an anchor vertex.
        # For each subsequent vertex v in S, attempt to union its component with the anchor's component.
        # This strategy ensures that all components represented in S get connected using edges of cost C,
        # without explicitly checking all pairs.
        u = S[0]
        
        # Iterate through the rest of the vertices in the set S (from index 1 onwards)
        for k in range(1, len(S)):
            v = S[k]
            
            # Attempt to union the components containing u and v.
            # The `union` function returns True if they were in different components and were merged.
            if union(u, v): 
                # If the union was successful, it corresponds to adding an edge (implicitly between u and v,
                # or more accurately, between their components) with weight C to our MST forest.
                total_weight += C # Add the cost of this edge to the total MST weight
                edges_count += 1 # Increment the count of edges included in the MST
                
                # A spanning tree for a graph with N vertices has exactly N-1 edges.
                # If we have added N-1 edges, we have found the MST.
                if edges_count == N - 1:
                    print(total_weight) # Output the total weight of the MST
                    return # Terminate the program as the MST is complete

    # After iterating through all operations, check the final state.
    # If exactly N-1 edges were added, the resulting graph is connected, and we have the MST weight.
    if edges_count == N - 1:
        # This case can be reached if the N-1th edge was added during the processing of the very last operation.
        print(total_weight) 
    else:
        # If fewer than N-1 edges were added after processing all operations,
        # it implies the final graph G is not connected. An MST for the entire graph does not exist.
        print("-1")

# Call the main function to start the process
solve()