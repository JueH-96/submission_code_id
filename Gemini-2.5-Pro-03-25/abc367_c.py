import sys
import itertools

# Define the main function to encapsulate the problem-solving logic
def solve():
    """
    Reads input, generates sequences, filters based on sum divisibility by K,
    and prints the valid sequences in lexicographical order.
    """
    # Read N (length of sequence) and K (divisor for sum) from the first line of input
    n, k = map(int, sys.stdin.readline().split())

    # Read the list R of upper bounds (R_i) from the second line of input
    r = list(map(int, sys.stdin.readline().split()))

    # Create a list of range objects. Each range represents the possible values
    # for the corresponding element in the sequence (from 1 to R_i, inclusive).
    ranges = []
    for limit in r:
        # range(start, stop) generates numbers from start up to (but not including) stop.
        # We need range(1, limit + 1) to include the upper bound 'limit'.
        ranges.append(range(1, limit + 1))

    # Use itertools.product to generate the Cartesian product of the defined ranges.
    # The asterisk (*) unpacks the 'ranges' list into separate arguments for the product function.
    # itertools.product generates tuples (representing sequences) in lexicographical order by default,
    # which satisfies the problem requirement.
    product_iterator = itertools.product(*ranges)

    # Iterate through each sequence generated by the product iterator
    for seq in product_iterator:
        # Calculate the sum of the elements in the current sequence (tuple 'seq')
        current_sum = sum(seq)

        # Check if the calculated sum is exactly divisible by K (i.e., sum % K == 0)
        if current_sum % k == 0:
            # If the sum condition is met, print the elements of the sequence.
            # The asterisk (*) before 'seq' unpacks the tuple into individual arguments for the print function.
            # By default, print separates arguments with a space and adds a newline character at the end.
            # This matches the required output format.
            print(*(seq))

# Execute the solve function when the script is run
if __name__ == '__main__':
    solve()