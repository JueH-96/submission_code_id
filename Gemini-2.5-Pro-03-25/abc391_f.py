# YOUR CODE HERE
import heapq
import sys

def solve():
    # Read N and K from input
    # N: length of the sequences A, B, C
    # K: the rank of the desired largest value (1st largest, 2nd largest, ..., K-th largest)
    N, K = map(int, sys.stdin.readline().split())
    
    # Read the three integer sequences A, B, C
    A = list(map(int, sys.stdin.readline().split()))
    B = list(map(int, sys.stdin.readline().split()))
    C = list(map(int, sys.stdin.readline().split()))

    # Sort the sequences in descending order.
    # This is crucial for the priority queue approach, as it allows us to start
    # exploring combinations from the one that yields the maximum possible value.
    # The maximum value is achieved when using the largest elements from A, B, and C.
    A.sort(reverse=True)
    B.sort(reverse=True)
    C.sort(reverse=True)

    # Initialize a min-heap (priority queue). Python's heapq module implements a min-heap.
    # To find the K-th largest value, we simulate a max-heap by storing the negative of the actual values.
    # Each element in the heap will be a tuple: (-value, (index_i, index_j, index_k))
    # This way, the smallest element in the min-heap corresponds to the largest actual value.
    pq = [] 
    
    # Initialize a set to keep track of visited index triplets (i, j, k).
    # This prevents processing the same combination multiple times, which could lead to
    # incorrect results and potentially infinite loops (though not possible here due to index bounds).
    visited = set()

    # Calculate the value for the initial state using indices (0, 0, 0).
    # After sorting A, B, C in descending order, A[0], B[0], C[0] are the largest elements.
    # The combination (0, 0, 0) yields the overall maximum value: A[0]*B[0] + B[0]*C[0] + C[0]*A[0].
    initial_val = A[0]*B[0] + B[0]*C[0] + C[0]*A[0]
    
    # Push the initial state (negative value and indices) onto the priority queue.
    heapq.heappush(pq, (-initial_val, (0, 0, 0)))
    # Mark the initial state (0, 0, 0) as visited.
    visited.add((0, 0, 0))

    # Counter for the number of values extracted from the priority queue.
    count = 0
    # Variable to store the K-th largest value once found. Initialized to -1.
    result = -1

    # Main loop: Repeat K times to find the K-th largest value.
    while count < K:
        # Safety check: If the priority queue becomes empty before finding K elements,
        # it implies K > N^3. Given the problem constraints (K <= min(N^3, 5*10^5)),
        # this condition should not be met if the input adheres to the constraints.
        if not pq: 
             break 

        # Pop the element with the smallest negative value from the min-heap.
        # This corresponds to the largest actual value currently available in the heap.
        neg_val, indices = heapq.heappop(pq)
        # Retrieve the actual value by negating the stored negative value.
        current_val = -neg_val
        # Unpack the indices (i, j, k) associated with this value.
        i, j, k = indices
        
        # Increment the counter, signifying that we have processed one more value from the sorted sequence.
        count += 1
        
        # Check if this is the K-th value we have extracted.
        if count == K:
            result = current_val # Store the K-th largest value.
            break # We found the required K-th value, so exit the loop.

        # Explore the "neighbors" of the current state (i, j, k).
        # Neighbors are generated by incrementing exactly one of the indices i, j, or k by 1.
        # Since the arrays are sorted descending, incrementing an index generally leads to smaller values.
        # This strategy explores combinations systematically from largest towards smaller values.
        
        # Consider neighbor state by incrementing index i: (i+1, j, k)
        ni, nj, nk = i + 1, j, k
        # Check if the new index ni is within the array bounds [0, N-1].
        if ni < N:
            neighbor_indices = (ni, nj, nk)
            # Check if this neighbor state has already been visited (i.e., added to the queue before).
            if neighbor_indices not in visited:
                # Calculate the value for this neighbor state using A[ni], B[nj], C[nk].
                val = A[ni]*B[nj] + B[nj]*C[nk] + C[nk]*A[ni]
                # Push the negative value and indices onto the priority queue.
                heapq.heappush(pq, (-val, neighbor_indices))
                # Mark this neighbor state as visited to avoid reprocessing it later.
                visited.add(neighbor_indices)

        # Consider neighbor state by incrementing index j: (i, j+1, k)
        ni, nj, nk = i, j + 1, k
        # Check if the new index nj is within bounds.
        if nj < N:
            neighbor_indices = (ni, nj, nk)
            # Check if visited.
            if neighbor_indices not in visited:
                # Calculate value.
                val = A[ni]*B[nj] + B[nj]*C[nk] + C[nk]*A[ni]
                # Push to priority queue.
                heapq.heappush(pq, (-val, neighbor_indices))
                # Mark visited.
                visited.add(neighbor_indices)

        # Consider neighbor state by incrementing index k: (i, j, k+1)
        ni, nj, nk = i, j, k + 1
        # Check if the new index nk is within bounds.
        if nk < N:
             neighbor_indices = (ni, nj, nk)
             # Check if visited.
             if neighbor_indices not in visited:
                # Calculate value.
                val = A[ni]*B[nj] + B[nj]*C[nk] + C[nk]*A[ni]
                # Push to priority queue.
                heapq.heappush(pq, (-val, neighbor_indices))
                # Mark visited.
                visited.add(neighbor_indices)

    # After the loop finishes (either by finding the K-th value or exhausting possibilities),
    # print the stored result, which is the K-th largest value.
    print(result)

# Execute the main function to solve the problem based on standard input.
solve()