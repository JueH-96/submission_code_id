import sys
from typing import List

# Setting recursion depth limit. For competitive programming platforms or environments 
# with deep recursion needs, it's often necessary to increase the default limit.
# A value like 2*10^5 should be sufficient for N up to 10^5, accounting for linear trees.
try:
    # This setting might fail in restricted environments, hence the try-except block.
    sys.setrecursionlimit(200005) 
except Exception as e:
    # If setting the limit fails, print a warning. The code might raise a RecursionError 
    # later for deep trees if the default limit is too low.
    print(f"Warning: Could not set recursion depth limit: {e}", file=sys.stderr)

class Solution:
  """
  This class implements the solution to find nodes in a tree whose specific DFS traversal string
  forms a palindrome. It uses an efficient approach based on polynomial rolling hashes with 
  double hashing to ensure correctness and handle large inputs within time limits.
  """
  def findAnswer(self, parent: List[int], s: str) -> List[bool]:
    """
    Calculates for each node `i` whether the string generated by a specific Depth-First Search (DFS) 
    starting from node `i` is a palindrome.

    The DFS process for a node `x` is defined as:
    1. Recursively call DFS on each child `y` of `x` in increasing order of their node numbers.
    2. Append the character `s[x]` to the DFS string.

    Args:
        parent: A list of integers representing the tree structure. `parent[i]` is the parent of node `i`. 
                `parent[0]` is -1, indicating node 0 is the root.
        s: A string where `s[i]` is the character associated with node `i`.

    Returns:
        A list of booleans `answer` of size `n`, where `answer[i]` is `True` if the DFS string 
        generated starting from node `i` is a palindrome, and `False` otherwise.
    """
    n = len(parent)
    
    # Build the adjacency list representation of the tree.
    # adj[i] will store a list of children for node i.
    adj = [[] for _ in range(n)]
    for i in range(1, n):
        # The problem statement guarantees parent[i] is valid for i >= 1.
        adj[parent[i]].append(i)
        # Children are automatically added in increasing order of their indices
        # because we iterate `i` from 1 to n-1.

    # --- Polynomial Rolling Hash Parameters ---
    # Using double hashing (two different sets of bases and moduli) reduces the 
    # probability of hash collisions significantly, making the palindrome check reliable.
    B1 = 31          # Prime base 1 (commonly used in string hashing)
    M1 = 10**9 + 7   # Large prime modulus 1
    B2 = 131         # Another prime base, different from B1
    M2 = 10**9 + 9   # Another large prime modulus, different from M1

    # --- Precompute Powers ---
    # Precompute powers of B1 modulo M1 and B2 modulo M2 up to n.
    # This avoids repeated calculations within the DFS.
    # powers1[k] = B1^k % M1
    # powers2[k] = B2^k % M2
    powers1 = [1] * (n + 1)
    powers2 = [1] * (n + 1)
    for i in range(1, n + 1):
        powers1[i] = (powers1[i-1] * B1) % M1
        powers2[i] = (powers2[i-1] * B2) % M2

    # --- Memoization Table ---
    # Stores the computed hash values and the length of the DFS string for each node 
    # to avoid redundant computations in the recursive calls.
    # Key: node index `x`
    # Value: tuple `(forward_hash1, reverse_hash1, forward_hash2, reverse_hash2, length)`
    hashes_memo = {} 

    # --- Recursive DFS Function for Hash Computation ---
    def compute_hashes_dfs(x: int):
        """
        Recursively computes the forward and reverse hashes (using two bases) and the length 
        of the DFS string for the subtree rooted at node `x`. Follows the post-order traversal 
        logic defined in the problem statement. Results are memoized.
        """
        # Check if the result for node x is already computed and memoized.
        if x in hashes_memo:
            return hashes_memo[x]

        # Initialize hash values and length for the combined string from children.
        # These represent the hash of the concatenated DFS strings of the children.
        current_h1 = 0
        current_rh1 = 0
        current_h2 = 0
        current_rh2 = 0
        current_len = 0

        # Process children recursively first (post-order traversal logic).
        # Children are processed in increasing order as stored in `adj[x]`.
        for child in adj[x]:
            # Get the hash information for the child's subtree.
            child_h1, child_rh1, child_h2, child_rh2, child_len = compute_hashes_dfs(child)

            # --- Update Hashes for String Concatenation ---
            # The effective string operation is: current_string = current_string + child_string
            
            # Update forward hash 1: H(current + child) = (H(current) * B1^len(child) + H(child)) % M1
            current_h1 = (current_h1 * powers1[child_len] + child_h1) % M1

            # Update reverse hash 1: RH(current + child) = (RH(child) * B1^len(current) + RH(current)) % M1
            current_rh1 = (child_rh1 * powers1[current_len] + current_rh1) % M1

            # Update forward hash 2 using base B2 and modulus M2
            current_h2 = (current_h2 * powers2[child_len] + child_h2) % M2

            # Update reverse hash 2 using base B2 and modulus M2
            current_rh2 = (child_rh2 * powers2[current_len] + current_rh2) % M2

            # Update the total length of the concatenated children strings.
            current_len += child_len

        # --- Incorporate the character s[x] ---
        # The character `s[x]` is appended to the end of the combined children strings.
        # Map character 'a'..'z' to integers 1..26. Using 1-based mapping avoids issues with character 'a' mapping to 0.
        char_val = ord(s[x]) - ord('a') + 1

        # Final string representation: (combined_children_string) + s[x]
        
        # Compute final forward hash 1: H(current + char) = (H(current) * B1^1 + char_val) % M1
        final_h1 = (current_h1 * B1 + char_val) % M1

        # Compute final reverse hash 1: RH(current + char) = (char_val * B1^len(current) + RH(current)) % M1
        final_rh1 = (char_val * powers1[current_len] + current_rh1) % M1

        # Compute final forward hash 2
        final_h2 = (current_h2 * B2 + char_val) % M2

        # Compute final reverse hash 2
        final_rh2 = (char_val * powers2[current_len] + current_rh2) % M2

        # Compute the final length of the DFS string for node x.
        final_len = current_len + 1

        # Store the computed result in the memoization table before returning.
        result = (final_h1, final_rh1, final_h2, final_rh2, final_len)
        hashes_memo[x] = result
        return result

    # --- Trigger Computation ---
    # Start the recursive hash computation from the root node 0.
    # Since the input is guaranteed to be a single tree rooted at 0, this call 
    # will traverse all nodes and populate the `hashes_memo` table for every node.
    compute_hashes_dfs(0)

    # --- Construct the Final Answer ---
    # Initialize the answer list with False.
    answer = [False] * n
    # Iterate through all nodes from 0 to n-1.
    for i in range(n):
         # Retrieve the computed hash information for node `i` from the memoization table.
         # We expect every node `i` to be present in `hashes_memo` because the graph is a connected tree.
         if i in hashes_memo: 
             # Unpack the hash values. The length is not needed for the palindrome check itself.
             h1, rh1, h2, rh2, _ = hashes_memo[i]
             
             # A string is a palindrome if its forward hash equals its reverse hash.
             # We check this condition using both sets of hashes (double hashing) for high confidence.
             if h1 == rh1 and h2 == rh2:
                 answer[i] = True
         # The else case (node `i` not in `hashes_memo`) should theoretically not happen given the problem constraints.
    
    return answer