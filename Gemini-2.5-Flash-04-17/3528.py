from collections import deque
from typing import List

class Solution:
    def findMaximumScore(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0

        # dp[i] stores the maximum score to reach index i from index 0.
        # The goal is to find dp[n-1].
        # The recurrence relation is:
        # dp[i] = max_{0 <= j < i} (dp[j] + (i - j) * nums[j])
        # Expanding the term:
        # dp[i] = max_{0 <= j < i} (dp[j] + i * nums[j] - j * nums[j])
        # dp[i] = max_{0 <= j < i} (i * nums[j] + (dp[j] - j * nums[j]))

        # This is the form suitable for Convex Hull Trick.
        # We want to evaluate the maximum value of lines y = m*x + c at x = i,
        # where m = nums[j] and c = dp[j] - j * nums[j].
        # We iterate i from 1 to n-1. For each i, we query the maximum value
        # from the lines generated by j = 0, 1, ..., i-1. After computing dp[i],
        # we add the line corresponding to index i to our set of lines.

        dp = [0] * n

        # Deque stores indices j that represent the lines y = nums[j]*x + (dp[j] - j*nums[j])
        # that form the upper envelope relevant for future queries (i.e., x values > current i).
        # The indices in the deque are ordered such that their corresponding lines' intersection
        # points are increasing. This allows O(1) query from the front due to monotonic queries (i).

        dq = deque([0]) # Start at index 0, dp[0] = 0. Add line L_0.

        # Helper functions to get the slope (m) and intercept (c) for a line L_j
        def get_m(j):
            # Slope is nums[j]
            return nums[j]

        def get_c(j):
            # Intercept is dp[j] - j * nums[j]
            # Note: dp[j] is available because j < i in the query phase,
            # and dp[i] is computed before adding line i in the add phase.
            return dp[j] - j * nums[j]

        # Check if line L_j2 is redundant when adding line L_i,
        # given j1 and j2 are the last two indices in the deque (dq[-2] and dq[-1]).
        # j2 is redundant if the intersection of L_j1 and L_j2 is at or to the right of the
        # intersection of L_j2 and L_i. This is equivalent to checking if the points
        # (m_j1, c_j1), (m_j2, c_j2), (m_i, c_i) form a non-left turn (collinear or right turn)
        # in the (m, c) plane.
        # The condition for a non-left turn is (m2 - m1) * (ci - c1) <= (mi - m1) * (c2 - c1).
        # Using Python's arbitrary precision integers to avoid overflow and floating point issues.
        def check_redundancy(j1, j2, i):
             m1, c1 = get_m(j1), get_c(j1)
             m2, c2 = get_m(j2), get_c(j2)
             mi, ci = get_m(i), get_c(i)

             # Check if the turn from j1 to j2 to i is non-left in the (m, c) plane.
             # Equivalent to checking if slope(j1, j2) >= slope(j2, i).
             # (c2 - c1) / (m2 - m1) >= (ci - c2) / (mi - m2)
             # Cross-multiply for integer comparison (careful with signs, determinant form is safer)
             # Determinant form check for non-left turn: (m2 - m1) * (ci - c1) <= (mi - m1) * (c2 - c1)
             return (m2 - m1) * (ci - c1) <= (mi - m1) * (c2 - c1)

        # Check if line L_j1 is worse than or equal to line L_j2 at the current query point x = i.
        # We remove j1 from the front of the deque if L_j1(i) <= L_j2(i).
        # m1 * i + c1 <= m2 * i + c2
        # Rearrange: i * (m1 - m2) <= c2 - c1
        def check_query(j1, j2, i):
             m1, c1 = get_m(j1), get_c(j1)
             m2, c2 = get_m(j2), get_c(j2)

             # Check if L_j1 is worse than or equal to L_j2 at x = i
             return i * (m1 - m2) <= c2 - c1

        for i in range(1, n):
            # Query phase: Find the optimal previous index j for the current index i.
            # Since queries (i) are increasing, the optimal j sequence moves towards
            # the back of the deque. We can remove suboptimal indices from the front.
            # Remove j1=dq[0] if L_j1 is worse than or equal to L_j2=dq[1] at x=i.
            while len(dq) >= 2 and check_query(dq[0], dq[1], i):
                 dq.popleft()

            # The optimal previous index is now at the front of the deque.
            j_opt = dq[0]

            # Compute the maximum score to reach the current index i.
            # dp[i] = nums[j_opt] * i + (dp[j_opt] - j_opt * nums[j_opt])
            #       = get_m(j_opt) * i + get_c(j_opt)
            dp[i] = get_m(j_opt) * i + get_c(j_opt)

            # Add phase: Add the line corresponding to the current index i to the deque.
            # This new line might make some existing lines at the back of the deque redundant.
            # Remove indices from the back while the convexity property is violated by adding line i.
            # A point j2 = dq[-1] is redundant if check_redundancy(dq[-2], j2, i) is True.
            while len(dq) >= 2 and check_redundancy(dq[-2], dq[-1], i):
                dq.pop()

            # Add the current index i to the back of the deque.
            dq.append(i)

        # The maximum score to reach the last index (n-1) is dp[n-1].
        return dp[n - 1]