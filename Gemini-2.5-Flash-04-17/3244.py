import math
from functools import reduce
from typing import List

class Solution:
    def minimumArrayLength(self, nums: List[int]) -> int:
        # Find the minimum element in the array
        min_val = min(nums)
        
        # Calculate the GCD of all elements in the array
        # Using functools.reduce and math.gcd
        # The GCD of an array [a, b, c] is gcd(a, gcd(b, c)).
        # We need to handle the case where gcd(0, x) = x. Since nums contains positive integers, 0 is not present initially.
        array_gcd = reduce(math.gcd, nums)
        
        # According to mathematical properties, the GCD of any subset of numbers
        # generated by the modulo operation on the original numbers will be a multiple of the original GCD.
        # Thus, any positive number remaining in the array after operations must be a multiple of array_gcd.
        # The smallest possible positive value we can ever have in the array is array_gcd.
        
        # If the minimum value in the initial array is not equal to the GCD of the array,
        # it means there is at least one number in the array that is not a multiple of the minimum value.
        # Performing modulo operations between such a number x and min_val (x % min_val)
        # can generate smaller positive values (r) where 0 < r < min_val.
        # This process of generating smaller positive values can continue until we reach array_gcd.
        # Once array_gcd (let's call it g) is present in the array, any other positive number x
        # (which is a multiple of g) can be combined with g using x % g = 0.
        # This operation removes x and g from the array and adds 0. This efficiently reduces
        # the count of positive numbers by 2.
        # If array_gcd is 1, we can generate 1. With 1 in the array, we can perform x % 1 = 0 for any x > 0.
        # This allows us to reduce the number of positive elements very efficiently.
        # If array_gcd > 1, and min_val > array_gcd, we can generate array_gcd.
        # The problem on numbers nums is equivalent to the problem on numbers [n / array_gcd for n in nums].
        # The latter array has a minimum value > 1 and a GCD of 1. The minimum length for a GCD=1 case seems to be 1.
        # If min_val > array_gcd, the minimum length is 1.
        
        # Since min_val must be a multiple of array_gcd (by definition of GCD), min_val >= array_gcd.
        # The condition min_val != array_gcd is equivalent to min_val > array_gcd.
        if min_val != array_gcd:
             return 1
        
        # If the minimum value is equal to the GCD of the array (min_val == array_gcd),
        # let g = min_val = array_gcd.
        # All initial numbers are multiples of g, and g itself is present.
        # Any positive number in the array throughout the process will be a multiple of g, and thus >= g.
        # Operations:
        # 1. g % g = 0. Removes two g's, adds 0. Reduces positive count by 2.
        # 2. x % g = 0 (for x > g, where x is a multiple of g). Removes x and g, adds 0. Reduces positive count by 2.
        # 3. x % y = z*g (for x, y > g). Removes x and y, adds z*g. If z=0, reduces positive count by 2. If z>0, reduces positive count by 1.
        # The smallest positive number we can have is g. We have count_g copies of g initially.
        # To minimize the final length, we want to perform as many operations as possible, stopping when positive count <= 1.
        # When min_val == g, all positive numbers are >= g. We cannot create smaller positive numbers.
        # The operations essentially combine multiples of g.
        # If we have count_g copies of g, the most efficient way to reduce the number of g's is g % g = 0.
        # Any other operation involving x > g might or might not produce g or 0.
        # Consider the 'g' units as fundamental. We have count_g of them. Any operation results in 0 or >= g.
        # If we have count_g copies of g, and other numbers x > g.
        # We can use x % g = 0 (if available) or g % g = 0. Both reduce positive count by 2 and consume one or two g's.
        # The number of positive elements we can end up with seems related to the initial count of g.
        # If we have count_g items of value g, and combining any two results in 0 (conceptually for reduction),
        # the minimum number of elements needed is like pairing socks. k items -> k//2 pairs + k%2 singles.
        # The number of required elements is k//2 + k%2. This equals (k+1)//2 for k >= 1.
        # The examples support this: count=1 -> (1+1)//2 = 1, count=2 -> (2+1)//2 = 1, count=3 -> (3+1)//2 = 2, count=4 -> (4+1)//2 = 2.
        # This formula (count_g + 1) // 2 represents the minimum number of positive elements required
        # when the smallest possible positive value is g, and we have count_g units of g.
        # All other numbers are multiples of g and can eventually be 'absorbed' by forming 0s when paired with g.
        # The minimum number of final positive elements will be determined by the initial count of g.

        count_min_val = nums.count(min_val)
        return (count_min_val + 1) // 2