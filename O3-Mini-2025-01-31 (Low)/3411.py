from typing import List
import sys
sys.setrecursionlimit(10000)

class Solution:
    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:
        # We'll implement a digit DP that given an integer n (n>=0)
        # returns a tuple (pop_sum, exp_sum) for all numbers from 1 to n.
        # (we exclude 0)
        #
        # The DP works on the binary representation of n.
        #
        # state(idx, tight, started):
        #   idx: current index in bits (from 0 to L-1)
        #   tight: whether we have matched the prefix so far.
        #   started: whether we already have started the number (nonzero seen)
        #
        # We also pass the "bits" list and the length L.
        
        from functools import lru_cache
        
        def dp(bits, pos, tight, started):
            if pos == len(bits):
                # if we started, we have a valid number; else count as 0.
                return (1, 0, 0) if started else (0, 0, 0)
            key = (pos, tight, started)
            # Use lru_cache in a nested function if needed.
            # We make dp() a closure so that bits is constant.
            if key in memo:
                return memo[key]
            ways = 0
            pop_sum = 0
            exp_sum = 0
            limit = bits[pos] if tight else 1
            # The weight of setting a 1 in this position.
            # The most significant bit corresponds to exponent = len(bits) - 1.
            weight = len(bits) - pos - 1
            for dig in range(0, limit+1):
                new_tight = tight and (dig == limit)
                new_started = started or (dig == 1)
                # For contribution at this digit:
                add = weight if (new_started and dig==1) else 0
                cnt, ps, es = dp(bits, pos+1, new_tight, new_started)
                ways += cnt
                pop_sum += (dig if new_started else 0) * cnt  + ps
                exp_sum += add * cnt + es
            memo[key] = (ways, pop_sum, exp_sum)
            return memo[key]
        
        # compute f(n) that returns (pop_sum, exp_sum) for numbers in [1,n]
        # For n == 0, return (0,0)
        def f(n):
            if n <= 0:
                return (0,0)
            nonlocal memo
            bits = list(map(int, bin(n)[2:]))
            memo = {}
            _, pop_sum, exp_sum = dp(bits, 0, True, False)
            return (pop_sum, exp_sum)
        
        # Now, given a "position" pos (1-indexed in big_nums),
        # we want to compute F(pos): the total exponent sum from the first pos elements of big_nums.
        #
        # Recall that big_nums is built by concatenating the powerful arrays for x = 1, 2, 3, ...
        # where the length contributed by x is pop(x), and exponent sum contributed is exp(x).
        #
        # Thus if we let:
        #    L(n) = sum_{x=1}^n pop(x)
        #    E(n) = sum_{x=1}^n exp(x)
        # Then F(pos) = E(n-1) + partial, where n is the smallest integer such that L(n) >= pos,
        # and partial is the sum of the first k exponents of the sorted (ascending) list of exponents in x,
        # with k = pos - L(n-1).
        #
        # For an integer n, its powerful array is generated by taking every set bit.
        # The bits in n (from least-significant to most-significant) correspond to exponents:
        #   For example, n = 11 (binary 1011). Its set bits (reading LSB->MSB) are at positions 0,1,3.
        # Sorted in ascending order these remain [0,1,3].
        def F(pos):
            # binary search for smallest n such that f(n)[0] >= pos.
            lo, hi = 1, 10**15  # hi is a safe upper bound (even if over‐estimated)
            while lo < hi:
                mid = (lo + hi) // 2
                pop_sum, _ = f(mid)  # f(mid)[0] = L(mid)
                if pop_sum >= pos:
                    hi = mid
                else:
                    lo = mid + 1
            n = lo
            pop_before, exp_before = f(n-1)  # contributions for numbers 1..n-1
            k = pos - pop_before  # k elements come from n’s powerful array
            # Now get n’s powerful array: these are the powers corresponding to set bits.
            # We want them sorted in ascending order, i.e. by exponent.
            arr = []
            num = n
            exp_idx = 0  # exponent for bit 0 is 0, bit1 is 1, etc.
            while num:
                if num & 1:
                    arr.append(exp_idx)
                num //=2
                exp_idx += 1
            arr.sort()
            partial = sum(arr[:k])
            return exp_before + partial
        
        # Process the queries:
        ans = []
        for a, b, mod in queries:
            # a and b are indices in big_nums; they are 0-indexed in our problem?
            # Check the samples: In sample 1, query = [1,3,7] gives big_nums[1..3] = [2,1,2]
            # so the indices of big_nums are 1-indexed.
            # We use F(pos) to denote sum of exponents for first pos elements.
            expo_from_minus = F(a) if a > 0 else 0  # F(a) gives sum for first a elements.
            expo_to = F(b+1)  # because if query is [a, b] with 0-indexing, then
            # but note: sample: a=1, b=3 → F(3) - F(1-?).
            # Let’s re-read sample 1: query = [1,3,7] and outcome: big_nums[1..3] = [2,1,2]
            # The product's exponent sum = (1 (from 2) + 0 (from 1) + 1 (from 2)) = 2.
            # So F(3) =2 and F(0)=0 if we treat indices as 1-indexed.
            # Our F(pos) definition assumed pos is the count of terms.
            # So if query gives [from, to] 1-indexed, then result = F(to) - F(from-1).
            # Given queries[i] = [from_i, to_i, mod_i] where the examples indicate 1-indexed.
            # So we do:
            total_exp = F(b) - (F(a-1) if a > 1 else 0)
            # The product = 2^(total_exp) mod mod.
            ans.append(pow(2, total_exp, mod))
        return ans

# For local testing:
if __name__ == "__main__":
    sol = Solution()
    # Example 1:
    print(sol.findProductsOfElements([[1,3,7]]))  # Expected [4]
    # Example 2:
    print(sol.findProductsOfElements([[2,5,3],[7,7,4]]))  # Expected [2,2]