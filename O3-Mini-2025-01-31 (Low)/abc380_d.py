def main():
    import sys, math
    data = sys.stdin.read().split()
    if not data:
        return
    s = data[0]
    Q = int(data[1])
    queries = list(map(int, data[2:]))
    n0 = len(s)
    
    # For each query, we need to determine the K-th character from the infinite string
    # generated by repeatedly applying the operation:
    #   S -> S + T, where T is S with each character case-flipped.
    # Note that the string at each step doubles its length.
    # Hence, if we denote S0 as the original s, then after one operation the string is:
    #   S1 = S0 + flip(S0)
    # and in general S_n = S_{n-1} + flip(S_{n-1}).
    # This recursive structure means that for any index K (1-indexed) we can decide 
    # whether it lies in the first half (S_{n-1}) or the second half (flip(S_{n-1})).
    # If it lies in the second half, then we “flip” the eventual answer.
    #
    # We define an iterative routine where:
    # 1. We first determine the smallest n (using n >= ceil(log2(K / n0)))
    #    such that the infinite string's length after n steps (which is n0*2^n)
    #    is at least K.
    # 2. Then, we iterate n times:
    #    – At each step, let L be the current block length.
    #    – Let half = L/2. If K is in the second half (i.e. K > half), then subtract half from K
    #      and flip a flag (to mark that we need to flip the final character).
    #    – Continue on the half in which K resides.
    # 3. When we have completed the iterations, K will be at most n0 and we return s[K-1]
    #    after flipping its case if the flag is set.
    
    results = []
    for K in queries:
        # If K does not exceed the original string length, it's just in s.
        if K <= n0:
            results.append(s[K-1])
            continue
        
        # Compute the number of iterations n required such that n0 * 2^n >= K.
        # n = ceil(log2(K / n0))
        n = math.ceil(math.log(K / n0, 2))
        # Determine the total length after n steps.
        block_length = n0 * (1 << n)
        flip_flag = False
        k = K
        
        # Iteratively resolve the position.
        while n > 0:
            half = block_length >> 1  # equivalent to block_length // 2
            if k > half:
                k -= half
                flip_flag = not flip_flag
            block_length = half
            n -= 1
            
        # At this point, block_length equals the base length (n0) and k is 1-indexed location in s.
        ch = s[k - 1]
        if flip_flag:
            # Flip case: uppercase becomes lowercase and vice versa.
            ch = ch.lower() if ch.isupper() else ch.upper()
        results.append(ch)
    
    sys.stdout.write(" ".join(results))
    
if __name__ == '__main__':
    main()