import sys

def solve():
    """
    Reads N from stdin and prints the N x N pattern to stdout.
    The pattern is generated by coloring concentric square regions
    alternately black ('#') and white ('.'), starting with black
    for the outermost layer, following the rules given in the problem.
    """
    N = int(sys.stdin.readline())

    # Create an N x N grid. We can initialize with '#' since the first
    # operation (outermost layer, i=1) colors the whole grid black.
    grid = [['#' for _ in range(N)] for _ in range(N)]

    # The pattern is formed by coloring concentric squares from the outside in.
    # The operations in the problem description iterate 1-indexed i from 1 to N.
    # For 1-indexed step i, the rectangle is from (i,i) to (j,j) where j = N + 1 - i.
    # The operation happens if i <= j, which means i <= N + 1 - i, or 2*i <= N + 1, or i <= (N + 1) / 2.
    # So, 1-indexed i goes from 1 up to floor((N+1)/2).
    # Let's use 0-indexed layer k, where k corresponds to the 1-indexed step i = k + 1.
    # k goes from 0 up to floor((N+1)/2) - 1.
    # The number of layers/operations that perform coloring is floor((N+1)/2).
    # In Python integer division, floor((N+1)/2) is (N+1)//2.
    num_coloring_operations = (N + 1) // 2

    # Iterate through the relevant operations k (0-indexed layer).
    # k = 0 corresponds to i = 1
    # k = 1 corresponds to i = 2
    # ...
    # k = num_coloring_operations - 1 corresponds to i = num_coloring_operations
    for k in range(num_coloring_operations):
        # Determine the color for the current operation/layer k.
        # The color is based on the 1-indexed step i = k + 1.
        # Color is '#' if i is odd, '.' if i is even.
        # This is equivalent to '#' if k is even, '.' if k is odd.
        char = '#' if k % 2 == 0 else '.'

        # Determine the bounds (0-indexed) of the square region colored in this step k.
        # The 1-indexed top-left corner is (i, i). In 0-indexed, this is (i-1, i-1) = (k, k).
        # The 1-indexed bottom-right corner is (j, j) where j = N + 1 - i.
        # Substituting i = k + 1, we get j = N + 1 - (k + 1) = N - k.
        # In 0-indexed, this bottom-right corner is (j - 1, j - 1) = (N - k - 1, N - k - 1).
        r_start = k
        c_start = k
        r_end = N - 1 - k
        c_end = N - 1 - k

        # Fill the square region with the determined color.
        # The loop range for k ensures that the rectangle is valid (r_start <= r_end and c_start <= c_end).
        # Python's range() is inclusive of the start and exclusive of the stop.
        # So, to include r_end and c_end, we loop up to r_end + 1 and c_end + 1.
        for r in range(r_start, r_end + 1):
            for c in range(c_start, c_end + 1):
                grid[r][c] = char

    # Print the final grid row by row.
    for r in range(N):
        print("".join(grid[r]))

# Call the solve function to run the program.
solve()